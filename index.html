<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Excel Editor — Debuggable Build (CSV/XLSX)</title>
<link rel="shortcut icon" href="data:image/x-icon;," />
<style>
  :root { --bg:#0b1020; --panel:#121932; --grid:#0f1530; --muted:#9fb0d0; --text:#e8eeff; --accent:#5ea0ff; --sel:#24325e; --err:#3b0f1a; --errBorder:#ff5577; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
  header{display:flex;gap:.5rem;align-items:center;padding:.75rem;border-bottom:1px solid #1b254b;background:linear-gradient(180deg,var(--panel),#0f1734)}
  header h1{font-size:16px;margin:0 1rem 0 0;opacity:.9;font-weight:600;letter-spacing:.2px}
  button, .btn-file, select{background:#1a2450;border:1px solid #2c3a74;border-radius:10px;padding:.5rem .75rem;color:var(--text);cursor:pointer}
  button:hover,.btn-file:hover, select:hover{background:#21306b}
  button[disabled]{opacity:.55;cursor:not-allowed}
  .btn-file{position:relative;overflow:hidden;display:inline-flex;align-items:center;gap:.5rem}
  .btn-file input{position:absolute;inset:0;opacity:0;cursor:pointer}
  .toolbar{display:flex;flex-wrap:wrap;gap:.5rem;margin-left:auto}
  .wrap{padding:12px}
  .sheet{background:var(--panel);border:1px solid #1b254b;border-radius:14px;overflow:auto;max-height:70vh;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  table{border-collapse:separate;border-spacing:0;min-width:720px}
  thead th{position:sticky;top:0;background:#121c3f;z-index:3;color:#cfe0ff;font-weight:600}
  tbody th{position:sticky;left:0;background:#121c3f;z-index:2;color:#cfe0ff;font-weight:600}
  th, td{border-right:1px solid #203066;border-bottom:1px solid #203066;min-width:100px}
  thead th:first-child{left:0;z-index:4}
  th{padding:.4rem .5rem;text-align:center}
  td{padding:0}
  td .cell{padding:.45rem .5rem;outline:none;min-height:32px}
  td .cell:focus{background:var(--sel)}
  tr:nth-child(even) td{background:var(--grid)}
  tr:nth-child(odd) td{background:#0e1430}
  .cell.err{background:var(--err)!important;border:1px solid var(--errBorder)}
  .status{display:flex;gap:1rem;align-items:center;margin-top:10px;color:var(--muted);flex-wrap:wrap}
  .status code{background:#0f1734;border:1px solid #1b254b;border-radius:8px;padding:.25rem .5rem;color:#bfe}
  .pill{border:1px solid #2a3b76;border-radius:999px;padding:.2rem .5rem}
  .hint{opacity:.8}
  .danger{color:#ff9da6}
  .ok{color:#9dffb3}
  .sheetPicker{display:none;gap:.5rem;align-items:center}
  .sheetPicker.active{display:flex}
  .debug{margin-top:10px;background:#0a122e;border:1px solid #1b254b;border-radius:12px;padding:8px;max-height:20vh;overflow:auto}
  .debug h3{margin:0 0 6px 0;font-size:12px;color:#bcd}
  .debug pre{margin:0;font-size:12px;white-space:pre-wrap;word-break:break-word}
  .debug .row{opacity:.9}
  @media (max-width:900px){th, td{min-width:80px} header{gap:.4rem} header h1{display:none}}
</style>
</head>
<body>
  <header>
    <h1>Mini Excel Editor</h1>
    <button id="newSheet" title="New blank sheet">New</button>
    <button id="addRow" title="Add a row">+ Row</button>
    <button id="addCol" title="Add a column">+ Col</button>
    <button id="delRow" title="Delete last row">– Row</button>
    <button id="delCol" title="Delete last column">– Col</button>

    <div class="toolbar">
      <label class="btn-file" title="Open CSV/XLSX">
        Open
        <input id="fileInput" type="file" accept=".csv, text/csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, .xlsx" />
      </label>
      <button id="saveCSV" title="Download as CSV">Export CSV</button>
      <button id="saveXLSX" title="Download as XLSX">Export XLSX</button>
      <div id="sheetPicker" class="sheetPicker">
        <span>Sheet:</span>
        <select id="sheetSelect"></select>
      </div>
      <button id="runTests" title="Quick self-test">Run Tests</button>
      <button id="toggleDebug" title="Show/hide debug log">Debug</button>
      <button id="copyDebug" title="Copy debug report">Copy Report</button>
    </div>
  </header>

  <div class="wrap">
    <div class="sheet">
      <table id="grid">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="status">
      <span class="pill hint">Tip: use formulas like <code>=A1+B2*2</code> or <code>=SUM(A1:A5,B2)</code></span>
      <span id="calcState" class="pill">Ready</span>
      <span id="xlsxState" class="pill">XLSX: not loaded</span>
      <span id="fileInfo" class="pill"></span>
    </div>

    <div id="debugBox" class="debug" style="display:none">
      <h3>Debug Log</h3>
      <pre id="debugOut"></pre>
    </div>
  </div>

  <script>
  (function(){
    const gridEl = document.getElementById('grid');
    const thead = gridEl.querySelector('thead');
    const tbody = gridEl.querySelector('tbody');
    const calcState = document.getElementById('calcState');
    const fileInfo = document.getElementById('fileInfo');
    const xlsxState = document.getElementById('xlsxState');
    const pickerWrap = document.getElementById('sheetPicker');
    const sheetSelect = document.getElementById('sheetSelect');
    const saveXLSXBtn = document.getElementById('saveXLSX');
    const debugBox = document.getElementById('debugBox');
    const debugOut = document.getElementById('debugOut');

    // In-memory sheet data model
    let rows = 30, cols = 12;
    let data = createEmpty(rows, cols); // stores raw strings (including formulas)

    // Error map: key "r,c" -> message
    const errMap = new Map();

    // XLSX lib reference (avoid global window access)
    let XLSXRef = null; // set after ensureXLSX()

    // For XLSX multi-sheet handling
    let currentWB = null; // Workbook object

    // ===== Debug helpers =====
    function log(...args){
      const line = `[${new Date().toISOString()}] ` + args.map(a=>{
        try{ return typeof a==='string'? a : JSON.stringify(a); }catch{ return String(a); }
      }).join(' ');
      console.log(...args);
      debugOut.textContent += line + "\n";
      debugOut.parentElement.scrollTop = debugOut.parentElement.scrollHeight;
    }
    document.getElementById('toggleDebug').onclick = ()=>{
      debugBox.style.display = debugBox.style.display==='none' ? 'block' : 'none';
    };
    document.getElementById('copyDebug').onclick = async ()=>{
      const report = collectReport();
      await navigator.clipboard.writeText(report);
      fileInfo.textContent = 'Debug report copied to clipboard';
    };
    function collectReport(){
      // basic environment + last 200 lines of debug
      const env = {
        ua: navigator.userAgent,
        xlsxLoaded: !!(XLSXRef||window.XLSX),
        rows, cols,
        errCount: errMap.size
      };
      const lines = debugOut.textContent.split(/\n/);
      const tail = lines.slice(Math.max(0, lines.length-200)).join('\n');
      return `ENV: ${JSON.stringify(env, null, 2)}\n\nLOG:\n${tail}`;
    }

    // ===== Robust XLSX loader (prevents ReferenceError) =====
    async function ensureXLSX(){
      if (XLSXRef) { xlsxState.textContent = 'XLSX: loaded'; return XLSXRef; }
      xlsxState.textContent = 'XLSX: loading…';
      const sources = [
        'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js',
        'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
        'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js'
      ];
      for (const src of sources){
        try{
          await loadScript(src, 12000);
          if (window.XLSX){
            XLSXRef = window.XLSX;
            xlsxState.textContent = 'XLSX: loaded';
            log('XLSX loaded from', src);
            return XLSXRef;
          }
        } catch(e){
          log('XLSX load failed from', src, e.message);
        }
      }
      xlsxState.textContent = 'XLSX: unavailable (CSV only)';
      log('XLSX unavailable after trying all CDNs');
      return null;
    }
    function loadScript(src, timeout=10000){
      return new Promise((resolve,reject)=>{
        const s = document.createElement('script');
        s.src = src; s.async = true; s.onload = () => resolve(); s.onerror = () => reject(new Error('load failed'));
        document.head.appendChild(s);
        const to = setTimeout(()=>{ reject(new Error('timeout')); }, timeout);
        s.addEventListener('load', ()=> clearTimeout(to));
        s.addEventListener('error', ()=> clearTimeout(to));
      });
    }

    // Utilities
    function createEmpty(r,c){ return Array.from({length:r},()=>Array.from({length:c},()=>'')); }
    function colLabel(n){ // 0->A, 25->Z, 26->AA
      let s=''; n = n>>>0; do{ s = String.fromCharCode(65 + (n % 26)) + s; n = Math.floor(n/26) - 1; } while(n>=0); return s;
    }
    function parseA1(ref){
      const m = /^([A-Z]+)(\d+)$/.exec(ref.toUpperCase());
      if(!m) return null;
      const c = m[1].split('').reduce((a,ch)=>a*26 + (ch.charCodeAt(0)-64),0)-1;
      const r = parseInt(m[2],10)-1;
      return {r, c};
    }

    // Rendering
    function renderHeader(){
      const tr = document.createElement('tr');
      tr.appendChild(document.createElement('th')); // corner
      for(let c=0;c<cols;c++){
        const th = document.createElement('th');
        th.textContent = colLabel(c);
        tr.appendChild(th);
      }
      thead.innerHTML='';
      thead.appendChild(tr);
    }
    function renderBody(){
      tbody.innerHTML='';
      for(let r=0;r<rows;r++){
        const tr = document.createElement('tr');
        const rowTh = document.createElement('th');
        rowTh.textContent = r+1;
        tr.appendChild(rowTh);
        for(let c=0;c<cols;c++){
          const td = document.createElement('td');
          const div = document.createElement('div');
          div.className='cell';
          div.contentEditable = true;
          div.dataset.r = r;
          div.dataset.c = c;
          div.textContent = displayValue(r,c);
          div.addEventListener('input', onEdit);
          div.addEventListener('blur', onBlurNormalize);
          td.appendChild(div);
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      applyErrorDecorations();
      // initial autofit for the newly rendered table
      autofitColumns();
    }

    // Caret helpers for flicker-free refresh
    function getCaret() {
      const el = document.activeElement;
      if (!el || !el.classList || !el.classList.contains('cell')) return null;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) return null;
      const range = sel.getRangeAt(0);
      return { el, r: +el.dataset.r, c: +el.dataset.c, start: range.startOffset, end: range.endOffset };
    }
    function setCaret(snap) {
      if (!snap) return;
      const { r, c, start, end } = snap;
      const el = tbody.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if (!el) return;
      const node = el.firstChild || el;
      const range = document.createRange();
      const len = (node.textContent || '').length;
      range.setStart(node, Math.min(start, len));
      range.setEnd(node, Math.min(end, len));
      const sel = window.getSelection();
      sel.removeAllRanges(); sel.addRange(range);
    }

    function refreshAllDisplay(){
      const snap = getCaret();
      for(const el of tbody.querySelectorAll('.cell')){
        const r = +el.dataset.r, c = +el.dataset.c;
        const newText = displayValue(r,c);
        if (el.textContent !== newText) el.textContent = newText;
      }
      applyErrorDecorations();
      setCaret(snap);
    }

    // Formula evaluation (simple & safe-ish)
    function rawValue(r,c){ return data[r]?.[c] ?? ''; }
    function numeric(v){ const n = Number(v); return isFinite(n) ? n : 0; }

    function sumFn(args){
      let total = 0;
      for(const a of args){
        if(typeof a === 'number'){ total += a; continue; }
        if(typeof a === 'string'){
          // Possibly a range like "A1:B3"
          const range = /^([A-Z]+\d+):([A-Z]+\d+)$/.exec(a.trim().toUpperCase());
          if(range){
            const a1 = parseA1(range[1]), a2 = parseA1(range[2]);
            if(a1 && a2){
              const r1=Math.min(a1.r,a2.r), r2=Math.max(a1.r,a2.r);
              const c1=Math.min(a1.c,a2.c), c2=Math.max(a1.c,a2.c);
              for(let r=r1;r<=r2;r++) for(let c=c1;c<=c2;c++) total += numeric(valueAt(r,c));
              continue;
            }
          }
          // Single ref?
          const p = parseA1(a);
          if(p){ total += numeric(valueAt(p.r,p.c)); continue; }
          total += numeric(a);
        }
      }
      return total;
    }

    function isBlankFormula(s){ return typeof s==='string' && /^=\s*$/.test(s); }

    function evaluateFormula(expr){
      const trimmed = expr.trim();
      if(trimmed==='') return '';
      // Replace cell refs with numeric values
      let e = trimmed.replace(/\b([A-Z]+[0-9]+)\b/gi, (m)=>{
        const p = parseA1(m); return numeric(valueAt(p.r,p.c));
      });
      // Allow only numbers, ops, commas, parentheses, dots, spaces, and SUM calls
      e = e.replace(/SUM\s*\(/gi, 'SUM(');
      if(!/^[0-9+\-*/().,\sSUM:A-Z]+$/i.test(e)) throw new Error('Invalid characters in formula');
      // Convert SUM(...) to helper
      const js = e.replace(/SUM\s*\(([^()]*)\)/gi, (_,inner)=>{
        const parts = inner.split(',').map(s=>s.trim()).filter(Boolean).map(tok=>/^[0-9.]+$/.test(tok) ? tok : JSON.stringify(tok));
        return `__SUM__([${parts.join(',')}])`;
      });
      if(!/^[0-9+\-*/().,\s"':A-Za-z\[\]]+$/.test(js)) throw new Error('Unsafe formula');
      const f = new Function('__SUM__', `return (${js});`);
      return f(sumFn);
    }

    function setError(r,c,msg){ errMap.set(`${r},${c}`, msg); }
    function clearError(r,c){ errMap.delete(`${r},${c}`); }

    function valueAt(r,c){
      const raw = rawValue(r,c);
      if(typeof raw !== 'string') { clearError(r,c); return raw ?? ''; }
      if(isBlankFormula(raw)) { clearError(r,c); return raw; }
      if(raw.startsWith('=')){
        try{
          const v = evaluateFormula(raw.slice(1));
          clearError(r,c);
          return v;
        }catch(e){
          setError(r,c, String(e.message||e));
          return 'ERR';
        }
      }
      clearError(r,c);
      return raw;
    }
    function displayValue(r,c){
      const raw = rawValue(r,c);
      if(isBlankFormula(raw)) return raw; // show '=' while user is typing
      if(typeof raw === 'string' && raw.startsWith('=')) {
        const v = valueAt(r,c);
        return v === 'ERR' ? 'ERR' : String(v);
      }
      return raw;
    }

    function applyErrorDecorations(){
      for(const el of tbody.querySelectorAll('.cell')){
        const r = +el.dataset.r, c = +el.dataset.c;
        const key = `${r},${c}`;
        if(errMap.has(key)){
          el.classList.add('err');
          el.title = `ERR: ${errMap.get(key)}`;
        } else {
          el.classList.remove('err');
          el.removeAttribute('title');
        }
      }
    }

    // Editing
    function onEdit(e){
      const el = e.currentTarget;
      const r = +el.dataset.r, c = +el.dataset.c;
      data[r][c] = el.textContent;
      recalc();
    }
    function onBlurNormalize(e){
      const el = e.currentTarget;
      // keep "=   " while user is composing a formula
      if (/^=\s*$/.test(el.textContent)) return;
      el.textContent = el.textContent.replace(/\s+/g,' ').trim();
    }

    // Throttled recalc (avoid flood while typing quickly)
    let recalcTimer = 0;
    function recalc(){
      calcState.textContent = 'Calculating…';
      clearTimeout(recalcTimer);
      recalcTimer = setTimeout(()=>{
        try{
          refreshAllDisplay();
          calcState.textContent = 'Ready';
        }catch(err){
          calcState.textContent = 'Error';
          log('Recalc error:', err.message||err);
        }
      }, 16); // ~60fps
    }

    // Row/Col ops
    document.getElementById('addRow').onclick = ()=>{
      data.push(Array.from({length:cols},()=>'')); rows++;
      renderHeader(); renderBody(); // autofit inside renderBody
    };
    document.getElementById('addCol').onclick = ()=>{
      for(const r of data) r.push('');
      cols++; renderHeader(); renderBody();
    };
    document.getElementById('delRow').onclick = ()=>{
      if(rows>1){ data.pop(); rows--; renderHeader(); renderBody(); }
    };
    document.getElementById('delCol').onclick = ()=>{
      if(cols>1){ for(const r of data) r.pop(); cols--; renderHeader(); renderBody(); }
    };
    document.getElementById('newSheet').onclick = ()=>{
      rows = 30; cols = 12; data = createEmpty(rows, cols);
      currentWB = null; pickerWrap.classList.remove('active'); sheetSelect.innerHTML=''; fileInfo.textContent = '';
      renderHeader(); renderBody(); recalc();
    };

    // CSV helpers
    function toCSV(){
      return data.map(row=>
        row.map(cell=>{
          const s = String(cell ?? '');
          if(/[,"\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
          return s;
        }).join(',')
      ).join('\n');
    }
    function parseCSV(text){
      const out = []; let row=[]; let i=0; let cur=''; let inQ=false;
      const pushCell =()=>{ row.push(cur); cur=''; };
      const pushRow =()=>{ out.push(row); row=[]; };
      while(i<text.length){
        const ch = text[i++];
        if(inQ){
          if(ch === '"'){
            if(text[i]==='"'){ cur+='"'; i++; } else { inQ=false; }
          }else cur += ch;
        }else{
          if(ch === '"'){ inQ=true; }
          else if(ch === ','){ pushCell(); }
          else if(ch === '\n'){ pushCell(); pushRow(); }
          else if(ch === '\r'){ /* ignore */ }
          else cur += ch;
        }
      }
      pushCell(); pushRow();
      const maxC = Math.max(...out.map(r=>r.length));
      return out.map(r=>r.concat(Array(Math.max(0,maxC-r.length)).fill('')));
    }

    function loadArray(arr){
      rows = arr.length;
      cols = Math.max(...arr.map(r=>r.length));
      data = createEmpty(rows, cols);
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) data[r][c]=arr[r][c]??'';
      renderHeader(); renderBody(); recalc();
    }

    // File open
    document.getElementById('fileInput').addEventListener('change', async (ev)=>{
      const file = ev.target.files[0]; if(!file) return; const name = file.name.toLowerCase();
      try{
        if(name.endsWith('.csv')){
          let txt = await file.text();
          // Strip UTF-8 BOM if present
          if (txt.charCodeAt(0) === 0xFEFF) txt = txt.slice(1);
          loadArray(parseCSV(txt));
          fileInfo.textContent = `Loaded CSV (${file.name})`;
          currentWB = null; pickerWrap.classList.remove('active'); sheetSelect.innerHTML='';
        }else{
          const lib = await ensureXLSX();
          if(!lib){ fileInfo.textContent = 'XLSX library unavailable — please open CSV instead'; return; }
          const buf = await file.arrayBuffer();
          const wb = lib.read(buf, {type:'array'});
          currentWB = wb;
          sheetSelect.innerHTML = '';
          wb.SheetNames.forEach((sn, i)=>{
            const opt = document.createElement('option');
            opt.value = sn; opt.textContent = sn;
            if(i===0) opt.selected = true;
            sheetSelect.appendChild(opt);
          });
          pickerWrap.classList.toggle('active', wb.SheetNames.length > 1);
          loadSheetByName(wb.SheetNames[0], lib);
          fileInfo.textContent = `Loaded XLSX (${file.name}) — ${wb.SheetNames.length>1? 'Select sheet':''}`;
        }
      }catch(err){
        fileInfo.textContent = 'Failed to open file';
        calcState.textContent = 'Error';
        log('Open error:', err.message||err);
      } finally {
        ev.target.value='';
      }
    });

    function loadSheetByName(name, lib){
      const L = lib || XLSXRef || window.XLSX; if(!currentWB || !L) return;
      const ws = currentWB.Sheets[name];
      const arr = L.utils.sheet_to_json(ws, {header:1, blankrows:true, defval:''});
      loadArray(arr); // render + autofit inside
    }
    sheetSelect.addEventListener('change', async ()=>{
      const lib = XLSXRef || await ensureXLSX();
      loadSheetByName(sheetSelect.value, lib);
    });

    // Save CSV
    document.getElementById('saveCSV').onclick = ()=>{
      const blob = new Blob([toCSV()], {type:'text/csv;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sheet.csv'; a.click(); URL.revokeObjectURL(a.href);
    };

    // Save XLSX (lazy-load lib to prevent ReferenceError)
    saveXLSXBtn.onclick = async ()=>{
      const lib = XLSXRef || await ensureXLSX();
      if(!lib){ fileInfo.textContent = 'XLSX export unavailable — library not loaded'; return; }
      const aoa = data.map(row=>row.slice());
      const ws = lib.utils.aoa_to_sheet(aoa);
      const wb = lib.utils.book_new();
      lib.utils.book_append_sheet(wb, ws, 'Sheet1');
      lib.writeFile(wb, 'sheet.xlsx');
    };

    // ===== Keyboard navigation (Enter/Shift+Enter, Tab/Shift+Tab, arrows) =====
    function focusCell(r,c){
      r = Math.max(0, Math.min(rows-1, r));
      c = Math.max(0, Math.min(cols-1, c));
      const el = tbody.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if (el){ el.focus(); placeCaretEnd(el); }
    }
    function placeCaretEnd(el){
      const range = document.createRange();
      const node = el.firstChild || el;
      const len = (node.textContent||'').length;
      range.setStart(node, len); range.setEnd(node, len);
      const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
    }
    tbody.addEventListener('keydown', (e)=>{
      const el = e.target.closest('.cell'); if (!el) return;
      const r = +el.dataset.r, c = +el.dataset.c;
      const go = (nr, nc)=>{ e.preventDefault(); focusCell(nr, nc); };
      if (e.key === 'Enter') return go(r + (e.shiftKey?-1:1), c);
      if (e.key === 'Tab')   return go(r, c + (e.shiftKey?-1:1));
      if (e.key === 'ArrowDown' && !e.shiftKey) return go(r+1, c);
      if (e.key === 'ArrowUp'   && !e.shiftKey) return go(r-1, c);
      if (e.key === 'ArrowLeft' && (e.ctrlKey||e.metaKey)) return go(r, c-1);
      if (e.key === 'ArrowRight'&& (e.ctrlKey||e.metaKey)) return go(r, c+1);
    });

    // ===== Paste from Excel/Sheets (tab/newline grid paste) =====
    tbody.addEventListener('paste', (e)=>{
      const el = e.target.closest('.cell'); if (!el) return;
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text');
      if (!text) return;
      const rowsClip = text.replace(/\r/g,'').split('\n').map(r=>r.split('\t'));
      const r0 = +el.dataset.r, c0 = +el.dataset.c;
      for (let i=0;i<rowsClip.length;i++){
        for (let j=0;j<rowsClip[i].length;j++){
          const rr = r0+i, cc = c0+j;
          if (rr<rows && cc<cols){ data[rr][cc] = rowsClip[i][j]; }
        }
      }
      renderBody(); recalc();
    });

    // ===== Auto-fit columns (lightweight) =====
    function autofitColumns(maxWidth=360){
      const ctx = document.createElement('canvas').getContext('2d');
      // Approximate table cell font (inherits from body)
      const bodyStyle = getComputedStyle(document.body);
      ctx.font = `${bodyStyle.fontSize} ${bodyStyle.fontFamily}`;
      const headerCells = thead.querySelectorAll('th');
      for(let c=0;c<cols;c++){
        let w = ctx.measureText(colLabel(c)).width + 24;
        for(let r=0;r<Math.min(rows, 50); r++){ // sample first 50 rows for speed
          const txt = String(displayValue(r,c));
          w = Math.max(w, ctx.measureText(txt).width + 24);
          if (w >= maxWidth) break;
        }
        const finalW = Math.min(Math.max(80, Math.ceil(w)), maxWidth); // clamp 80..maxWidth
        // nth-child: +2 because first column is row header <th>
        const tdList = tbody.querySelectorAll(`td:nth-child(${c+2})`);
        tdList.forEach(td => { td.style.width = finalW + 'px'; td.style.maxWidth = finalW + 'px'; });
        if (headerCells[c+1]){
          headerCells[c+1].style.width = finalW + 'px';
          headerCells[c+1].style.maxWidth = finalW + 'px';
        }
      }
    }

    // ===== Runtime self-tests =====
    document.getElementById('runTests').onclick = async ()=>{
      const results = [];
      // Existing Test 1: formula evaluation
      const bak = data.map(r=>r.slice()); const bakRows=rows, bakCols=cols;
      rows=2; cols=3; data=createEmpty(rows,cols);
      data[0][0]='1'; data[0][1]='2'; data[0][2]='=A1+B1*3';
      const val = valueAt(0,2);
      results.push(val===7 ? '✓ Formula (=A1+B1*3) == 7' : `✗ Formula expected 7 got ${val}`);

      // Existing Test 2: CSV roundtrip
      const csv = toCSV();
      const arr = parseCSV(csv);
      const ok2 = arr[1][3]===undefined && arr[0][0]==='1' && arr[0][1]==='2' && arr[0][2]==='=A1+B1*3';
      results.push(ok2 ? '✓ CSV roundtrip' : '✗ CSV roundtrip failed');

      // Restore sheet
      rows=bakRows; cols=bakCols; data=bak; renderHeader(); renderBody();

      // Existing Test 3: XLSX availability (no failure if offline)
      results.push((XLSXRef||window.XLSX) ? '✓ XLSX present' : '• XLSX not loaded (CSV still OK)');

      // Added Test 4: SUM(range) evaluation
      rows=3; cols=3; data=createEmpty(rows,cols);
      data[0][0]='1'; data[0][1]='2'; data[1][0]='3'; data[1][1]='4';
      data[2][2]='=SUM(A1:B2)';
      const sumVal = valueAt(2,2);
      results.push(sumVal===10 ? '✓ SUM(A1:B2) == 10' : `✗ SUM expected 10 got ${sumVal}`);

      // Added Test 5: A1 parse + colLabel check
      const p = parseA1('AA10');
      const lbl = colLabel(27); // 0-based 27 -> AB
      const ok5 = p && p.r===9 && p.c===26 && lbl==='AB';
      results.push(ok5 ? '✓ A1 parse & colLabel' : '✗ A1 parse/label failed');

      // Added Test 6: Unsafe formula handled
      data[0][0]='=A1+BADFUNC(1)';
      const unsafe = valueAt(0,0);
      results.push(unsafe==='ERR' ? '✓ Unsafe formula -> ERR' : `✗ Unsafe formula not blocked (${unsafe})`);

      // Added Test 7: Blank '=' preserved
      data[0][0]='='; const blank = valueAt(0,0);
      results.push(blank==='=' ? '✓ Blank formula (=) kept' : `✗ '=' should be kept, got ${blank}`);

      // Added Test 8: Whitespace-only after '=' preserved
      data[0][0]='=   '; const blank2 = valueAt(0,0);
      results.push(/^=\s*$/.test(blank2) ? '✓ Whitespace-only formula kept' : `✗ '=   ' should be kept, got ${blank2}`);

      // Restore again
      rows=bakRows; cols=bakCols; data=bak; renderHeader(); renderBody();

      fileInfo.textContent = results.join(' | ');
      log('Test results:', results.join(' | '));
    };

    // ===== Init =====
    renderHeader(); renderBody(); recalc();
  })();
  </script>
</body>
</html>
